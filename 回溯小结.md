### Day30

#### 关于复杂度  
1. 子集问题分析：  
* 时间复杂度：$O(n × 2^n)，因为每一个元素的状态无外乎取与不取，所以时间复杂度为$O(2^n)，构造每一组子集都需要填进数组，又有需要$O(n)，最终时间复杂度：$O(n × 2^n)。  
* 空间复杂度：$O(n)，递归深度为n，所以系统栈所用空间为$O(n)，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，
就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为$O(n)。 

2. 排列问题分析：  
* 时间复杂度：$O(n!)，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，
所以一直到叶子节点一共就是 n * n-1 * n-2 * ..... 1 = n!。每个叶子节点都会有一个构造全排列填进数组的操作（对应的代码：result.push_back(path)），该操作的复杂度为$O(n)。
所以，最终时间复杂度为：n * n!，简化为$O(n!)。  
* 空间复杂度：$O(n)，和子集问题同理。  

3. 组合问题分析：  
* 时间复杂度：$O(n × 2^n)，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。  
* 空间复杂度：$O(n)，和子集问题同理。 

4. N皇后问题分析：
* 时间复杂度：O(n!) ，其实如果看树形图的话，直觉上是O(n^n)，但皇后之间不能见面所以在搜索的过程中是有剪枝的，最差也就是O（n!） 
* 空间复杂度：O(n)，和子集问题同理。  

5. 解数独问题分析： 
* 时间复杂度：O(9^m) , m是'.'的数目。  
* 空间复杂度：O(n^2)，递归的深度是n^2  


#### 适用范围  

组合问题：N个数里面按一定规则找出k个数的集合  
排列问题：N个数按一定规则全排列，有几种排列方式  
切割问题：一个字符串按一定规则有几种切割方式  
子集问题：一个N个数的集合里有多少符合条件的子集  
棋盘问题：N皇后，解数独等等  

#### Templete  
```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```
